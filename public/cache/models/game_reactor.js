// Generated by CoffeeScript 1.3.1
(function() {
  var GameReactor, exp,
    __slice = [].slice;

  GameReactor = (function() {

    GameReactor.name = 'GameReactor';

    function GameReactor(game, events, time) {
      this.game = game;
      this.events = events;
      this.time = time != null ? time : 0;
      this.workers = [];
      this.slots = this.events;
      this.items = [];
      this.resources = this.game.resources;
      this.mining = new MiningReactor(this);
    }

    GameReactor.prototype.moveTo = function(time) {
      var _results;
      this.time = 0;
      this.running_production = [];
      _results = [];
      while (this.time < time) {
        _results.push(this.nextTick());
      }
      return _results;
    };

    GameReactor.prototype.nextTick = function() {
      this.process_events_ending_at(this.time);
      this.process_events_starting_at(this.time);
      this.mining.mine(this.workers, this.resources);
      return this.time += 1;
    };

    GameReactor.prototype.addCompleted = function(item) {
      var buildable;
      this.items.push(item);
      buildable = item.get('buildable');
      console.log(buildable);
      if (buildable !== null) {
        if (buildable.attributes.worker) {
          this.addWorker(item);
        }
        return this.resources.add_max_supply(buildable.provides_supply);
      }
    };

    GameReactor.prototype.addWorker = function(worker) {
      this.workers.push(worker);
      return this.log("added worker", worker.log());
    };

    GameReactor.prototype.process_events_starting_at = function(time) {
      var slot, started_item, starting_production, _i, _j, _len, _len1, _ref, _results;
      starting_production = [];
      _ref = this.slots.models;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        slot = _ref[_i];
        if (!slot.isAvailableAt(time)) {
          continue;
        }
        starting_production.push.apply(starting_production, slot.queue.where({
          starts_at: time
        }));
      }
      _results = [];
      for (_j = 0, _len1 = starting_production.length; _j < _len1; _j++) {
        started_item = starting_production[_j];
        _results.push(this.process_buildable_event_start(started_item));
      }
      return _results;
    };

    GameReactor.prototype.process_buildable_event_start = function(started_item) {
      var buildable, can_build;
      buildable = started_item.get('buildable');
      can_build = false;
      if (!this.resources.can_cover(buildable.cost)) {
        this.error("Not enough resources for ", started_item.log(), this.resources.log());
        started_item.set({
          can_be_built: false
        });
        return false;
      }
      this.resources.deduct(buildable.cost);
      started_item.set({
        can_be_built: true
      });
      this.running_production.push(started_item.cid);
      return this.log("STARTING PRODUCTION | ", started_item.log());
    };

    GameReactor.prototype.process_events_ending_at = function(time) {
      var ended_item, ending_production, slot, _i, _j, _len, _len1, _ref;
      ending_production = [];
      _ref = this.slots.models;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        slot = _ref[_i];
        if (!slot.isAvailableAt(time)) {
          continue;
        }
        ending_production.push.apply(ending_production, slot.queue.where({
          ends_at: time
        }));
      }
      for (_j = 0, _len1 = ending_production.length; _j < _len1; _j++) {
        ended_item = ending_production[_j];
        if (_(this.running_production).indexOf(ended_item.cid) === -1) {
          this.error("cannot end production of not-queued " + (ended_item.log()));
          return false;
        }
        this.log("ENDING: ", ended_item.log());
        this.addCompleted(ended_item);
      }
    };

    GameReactor.prototype.log = function() {
      var message;
      message = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return console.log.apply(console, ["[GameReactor] "].concat(__slice.call(message)));
    };

    GameReactor.prototype.error = function() {
      var message;
      message = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return console.error.apply(console, ["[GameReactor] "].concat(__slice.call(message)));
    };

    return GameReactor;

  })();

  exp = typeof exports !== "undefined" && exports !== null ? exports : this;

  exp.GameReactor = GameReactor;

}).call(this);
